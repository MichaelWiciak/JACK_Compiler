# JACK Compiler

## Overview

The JACK Compiler is a project designed to compile code written in the JACK programming language into VM code. The compiler consists of several interconnected components: a lexer, parser, symbol table, and code generation module. Each component plays a vital role in transforming JACK source code into executable instructions.

## Features

- **Lexical Analysis**: Converts JACK source code into tokens, identifying keywords, identifiers, symbols, numbers, and strings.
- **Parsing**: Constructs a parse tree and checks the source code against the JACK syntax rules.
- **Symbol Table Management**: Maintains a symbol table to track variables, methods, and classes within their respective scopes.
- **Code Generation**: Translates the parsed structure into VM code that can be executed by a virtual machine.

## Components

### Lexer

The lexer is responsible for reading the JACK source code line by line, identifying and tokenizing different elements. It scans the input for keywords, symbols, identifiers, numbers, and strings, generating a stream of tokens that will be passed to the parser. The lexer also handles error detection for invalid tokens.

### Parser

The parser processes the stream of tokens generated by the lexer. It constructs a parse tree according to the grammatical structure of JACK code. By applying grammar rules, the parser verifies that the code is syntactically correct and builds a hierarchical representation of the code's structure. During this process, it also checks for semantic errors, such as variable redeclarations and scope issues.

### Symbol Table

The symbol table plays a crucial role in tracking identifiers (like variables and methods) and their attributes (such as type and scope). As the parser identifies new declarations, it updates the symbol table accordingly. This allows the compiler to manage scopes effectively, enabling nested structures and functions. The symbol table also aids in error detection, ensuring that identifiers are declared before they are used.

### Compiler

The compiler orchestrates the entire process, bringing together the lexer, parser, and symbol table. It initializes the compilation process, manages the flow of data between components, and ultimately generates VM code. The compiler first invokes the lexer to produce tokens, then hands them off to the parser for analysis, and finally generates output based on the parse tree.

## How It Works

1. **Input Handling**: The compiler begins by reading the JACK source code file and initializing the lexer.
2. **Lexical Analysis**: The lexer scans the source code and generates a stream of tokens.
3. **Parsing**: The parser takes the tokens and constructs a parse tree while checking for syntax and semantic errors. If any errors are found, appropriate messages are returned.
4. **Symbol Table Management**: Throughout the parsing process, the compiler updates the symbol table to track the identifiers in the current scope.
5. **Code Generation**: After successfully parsing the code, the compiler generates VM code based on the parse tree, which can be executed by a virtual machine.
6. **Output**: The generated VM code is written to an output file, ready for execution.

## Building the Compiler

To build the JACK Compiler, follow these steps:

1. Ensure you have a C compiler installed (e.g., GCC).
2. Clone this repository:
   ```bash
   git clone <repository-url>
   cd jack-compiler
   ```
3. Compile the source code:
   ```bash
   gcc -o jack_compiler lexer.c parser.c symbol_table.c compiler.c
   ```

## Running the Compiler

To run the JACK Compiler, use the following command:

```bash
./jack_compiler <path-to-jack-source-file>
```

Replace `<path-to-jack-source-file>` with the path to your JACK source code file.

## Usage

1. Write your JACK code in a `.jack` file.
2. Compile the code using the compiler.
3. Check the generated VM code for correctness.


Certainly! Here’s a detailed section that discusses the technical implementation of each part of the JACK Compiler. This will cover the architecture, functionality, and interactions of the lexer, parser, symbol table, and code generator.

---

## Technical Details of the JACK Compiler Implementation

### Overview

The JACK Compiler is structured into several distinct modules, each responsible for specific tasks in the compilation process. These modules work together to transform JACK source code into VM code, ensuring both syntactic and semantic correctness. This section delves into the technical details of each component, explaining their roles, functionalities, and interdependencies.

### 1. Lexer

The lexer (or lexical analyzer) is the first component of the JACK Compiler. Its primary role is to convert the raw JACK source code into a stream of tokens. Here’s how it is implemented:

#### Functionality
- **Input Handling**: The lexer reads the source code character by character. It maintains a buffer to accumulate characters until a complete token is formed.
- **Token Types**: The lexer recognizes various token types, including:
  - Keywords (e.g., `class`, `method`, `function`)
  - Identifiers (e.g., variable and method names)
  - Symbols (e.g., `{`, `}`, `(`, `)`, `;`)
  - Numbers and strings
  - Errors (invalid tokens)

#### Implementation
- The lexer uses a finite state machine (FSM) approach to recognize different token types.
- As it scans the input, it transitions between states based on the current character and accumulates valid characters for tokens.
- When a complete token is recognized, it is added to the token stream, and the lexer prepares for the next token by resetting its buffer.
- The lexer also checks for comments and ignores them, ensuring that they do not affect the token stream.

### 2. Parser

The parser takes the stream of tokens generated by the lexer and constructs a parse tree based on the syntax of the JACK language.

#### Functionality
- **Grammar Rules**: The parser uses a context-free grammar (CFG) to validate the syntax of JACK code. It checks whether the tokens form valid statements, expressions, and declarations.
- **Error Handling**: The parser detects syntax errors and semantic errors (e.g., using undeclared variables) and provides meaningful feedback.

#### Implementation
- The parser is implemented using recursive descent parsing, where each function corresponds to a grammar rule. For instance, a function for handling `classDeclaration` will parse a class definition.
- Each parsing function consumes tokens from the token stream and verifies that they conform to the expected structure defined by the grammar rules.
- The parser constructs a hierarchical representation of the code (parse tree) as it successfully parses constructs, enabling easier code generation later.
- The parser manages scope using a stack-like structure to handle nested blocks and function calls, ensuring proper context for variable declarations and usages.

### 3. Symbol Table

The symbol table is a crucial data structure that keeps track of identifiers (variables, methods, and classes) and their attributes, such as type, scope, and location.

#### Functionality
- **Scope Management**: The symbol table supports nested scopes, allowing local variables to be defined within methods and classes while also tracking class-level variables.
- **Error Detection**: The symbol table helps detect redeclaration errors and scope-related issues.

#### Implementation
- The symbol table is typically structured as a linked list of symbol entries, with each entry containing information about an identifier (name, type, kind, and memory location).
- When a new identifier is declared, the parser interacts with the symbol table to insert the new symbol, checking for existing declarations to avoid redeclaration errors.
- The symbol table provides lookup functions to check for the existence of identifiers in the current scope, allowing for proper resolution of variable and method calls.
- The symbol table is updated dynamically as the parser processes the code, ensuring that it accurately reflects the current state of identifiers.

### 4. Code Generation

The code generation module translates the parse tree into VM code, which can be executed by the JACK Virtual Machine.

#### Functionality
- **Output Format**: The generated VM code follows the specific format required by the JACK Virtual Machine, including instructions for memory allocation, arithmetic operations, and control flow.
- **Functionality Mapping**: The code generation module maps JACK constructs (like classes and methods) to corresponding VM operations.

#### Implementation
- The code generation process starts after successful parsing. It traverses the parse tree, generating VM instructions for each node based on its type.
- The module maintains a context of the current scope and keeps track of local variables and their offsets in memory.
- For method and function definitions, the code generator outputs VM commands to allocate memory for local variables, set up the function call stack, and manage control flow (e.g., jumps for loops and conditionals).
- Special cases, such as constructors, are handled by generating additional instructions for object memory allocation.
- The generated VM code is written to an output file, which can be executed by the JACK Virtual Machine.

### Interactions Between Components

The components of the JACK Compiler are tightly integrated, working in a coordinated manner:

- The **lexer** feeds tokens into the **parser**. The parser consumes these tokens to build the parse tree while managing scope through the **symbol table**.
- As the parser identifies declarations and usages of identifiers, it interacts with the symbol table to insert, look up, and validate identifiers.
- Upon successfully constructing the parse tree, the **code generation** module traverses the tree to produce VM code, utilizing information from the symbol table to generate correct memory accesses and function calls.

### Conclusion

The JACK Compiler is an example of a modular compiler architecture, with each component designed to handle specific tasks in the compilation process. By leveraging structured approaches like lexical analysis, parsing, and symbol table management, the compiler ensures that JACK code is transformed into efficient VM code while maintaining correctness throughout the process.



## Additional Interesting Details of the JACK Compiler Implementation

### 1. Design Choices

#### Recursive Descent Parsing
The decision to implement a recursive descent parser allows for a clear and straightforward representation of the language grammar. Each function directly corresponds to a grammar rule, making the code easier to read and maintain. While this approach may not be the most efficient for very complex grammars, it simplifies debugging and understanding the parsing logic.

#### Tokenization Strategy
The lexer is designed to handle input flexibly. It includes mechanisms to skip whitespace and comments seamlessly, which helps keep the token stream clean and focused solely on meaningful constructs. This design choice reduces the complexity of the parser, as it only deals with relevant tokens.

### 2. Error Handling Mechanisms

#### Rich Error Feedback
Both the lexer and parser are equipped with mechanisms to provide detailed error messages, including token context (e.g., line number and found token). This feedback is invaluable for debugging, as it allows developers to quickly identify the source of errors in their JACK code.

#### Semantic Error Checks
Beyond syntactic checks, the parser integrates semantic checks by consulting the symbol table. This integration helps catch errors such as using undeclared variables or attempting to call methods with incorrect arguments, contributing to the robustness of the compilation process.

### 3. Symbol Table Enhancements

#### Hierarchical Structure
The symbol table implementation is designed to support nested scopes, which is essential for a language that allows methods and classes to contain local variables. This hierarchical structure simplifies the management of variable lifetimes and visibility, ensuring that local variables do not interfere with global or class-level variables.

#### Symbol Entry Attributes
Each entry in the symbol table carries more than just the identifier name; it also includes information about the type (e.g., integer, boolean), kind (e.g., variable, method), and memory location. This comprehensive metadata supports both static and dynamic type checking, facilitating better code generation.

### 4. Code Generation Considerations

#### Intermediate Representation
The compiler’s architecture allows for the possibility of adding an intermediate representation (IR) stage between parsing and code generation. This IR can be beneficial for optimization purposes, enabling further transformations before generating VM code. 


### Testing and Validation

#### Unit Tests
The compiler’s components are designed with testability in mind. Individual units such as the lexer, parser, and symbol table can be tested separately using unit tests provided to validate their functionalities. 

#### Integration Tests
Beyond unit tests, integration tests exist to ensure that all components work seamlessly together, validating the complete compilation process from JACK source to VM code. 

#### Example Programs
To validate the compiler’s correctness and performance, a suite of example JACK programs was created, covering a range of scenarios from simple programs to more complex applications. This suite serves as both a benchmark and a demonstration of the language’s capabilities.
